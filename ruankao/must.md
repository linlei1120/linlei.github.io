## 第六章 结构化开发方法
### 1、7种耦合类型
&emsp;&emsp;**（1）无直接耦合：** 模块间没有直接的关系，不传递任何消息，耦合性最低，独立性最高；

&emsp;&emsp;**（2）数据耦合：** 模块间由调用关系，值传递简单的数据值，相当于值传递；

&emsp;&emsp;**（3）标记传递：** 模块间传递数据结构；

&emsp;&emsp;**（4）控制耦合：** 模块间传递控制变量，调用模块具有多少功能，起什么作用由被调用模块控制；

&emsp;&emsp;**（5）外部耦合：** 模块间通过软件之外的环境联结；

&emsp;&emsp;**（6）公共耦合：** 通过一个公共数据环境相互作用的那些模块间的耦合；

&emsp;&emsp;**（7）内容耦合；** 一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部；

## 2、7种内聚类型
&emsp;&emsp;**（1）偶然内聚：** 一个模块内各处理单元之间没有联系；

&emsp;&emsp;**（2）逻辑内聚：** 模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成那个功能；

&emsp;&emsp;**（3）时间内聚：** 把需要同时执行的动作组合在一起形成的模块；

&emsp;&emsp;**（4）过程内聚：** 指一个模块完成多个任务这些任务必须按指定的过程执行；

&emsp;&emsp;**（5）通信内聚：** 指某模块内的所有处理元素都在同一个数据结构上操作；

&emsp;&emsp;**（6）顺序内聚：** 指一个模块中的各个处理元素都密切像关于同一个功能且必须顺序执行，前一个功能的输出就是下一个功能的输入；

&emsp;&emsp;**（7）功能内聚：** 指模块内所有元素共同作用完成一个功能，缺一不可；

## 第七章 面向对象技术
### 1、面向对象分析5个活动
&emsp;&emsp;认定对象、组织对象、描述对象间相互作用、确定对象的操作、认定对象的内部信息；

### 2、面向对象设计5个活动
&emsp;&emsp;识别类及对象、定义属性、定义服务、识别关系、识别包；

### 3、面向对象测试4个层次
&emsp;&emsp;面向对象测试4个层次；

### 4、多态
&emsp;&emsp;多态指的是不同的对象收到同一消息可以产生完全不同的结果；主要分为两类：参数多态、包含多态、过载多态、强制多态；

&emsp;&emsp;**参数多态：** 采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型；

&emsp;&emsp;**包含多态：** 可以实现子类型化，即一个类型是另一个类型的子类型；

&emsp;&emsp;**过载多态：** 同一个名字在不同的上下文中所代表的含义不同；

&emsp;&emsp;强制多态：强制多态是指将一种类型的值转换为另一种类型的值进行语义操作，从而防止	类型错误；类型转换可以是隐式的，在编译时完成;也可以是显式的，可在动态运行时完成；

### 5、面向对象设计基本原则
&emsp;&emsp;**① 单一责任原则：** 就一个类而言，应该仅有一个引起其变化的原因

&emsp;&emsp;**② 开放-封闭原则：** 软件实体应该是可扩展的(开放的)，但是不可修改的(封闭的)

&emsp;&emsp;**③ 里氏替换原则：** 子类型必须能够替换掉他们的基类型；

&emsp;&emsp;**④ 依赖倒置原则：** 高层模块不应该依赖于底层模块，二者都应该依赖于抽象；

&emsp;&emsp;**⑤ 接口分离原则：** 不应该强迫客户依赖于他们不用的方法，接口属于用户，不属于它所在的类层次结构，依赖于抽象，不要依赖于具体；

&emsp;&emsp;**⑥ 共同封闭原则：** 包中的所有类对于同一类性质的变化应该是共同封闭的，对包内所有类有影响，但对其他包无影响；

&emsp;&emsp;**⑦ 共同重用原则：** 如果重用了包中一个类，那么就要重用包中所有类；

### 6、UML的图
&emsp;**（1）类图**

&emsp;&emsp;**① 作用：** 展现了一组对象、接口、协作和他们之间的关系，用于对系统的静态设计视图建模；

&emsp;&emsp;**② 包含内容：** 类、接口、协作、依赖、泛化和关联关系；

&emsp;&emsp;**③ 使用场景：** 对系统的词汇建模、对简单的协作建模、对逻辑数据库模式建模；

&emsp;&emsp;**④ 抽象类：** 用{ abstract }标识，不能实例化所以没有直接对象；

&emsp;**（2）对象图**

&emsp;&emsp;**① 作用：** 展现了某一时刻一组对象以及它们之间的关系，从真实的或原型实例角度建立静态设计视图和静态进程视图；

&emsp;&emsp;**② 包含内容：** 对象、链；

&emsp;&emsp;**③ 使用场景：** 对静态数据结构建模；对象结构建模涉及在给定时刻抓取系统中对象的快照；

&emsp;**（3）用例图**

&emsp;&emsp;**① 作用：** 展现了一组用例、参与者以及他们之间的关系，对系统的静态用例视图进行建模用来支持系统的行为；

&emsp;&emsp;**② 包含内容：** 用例、参与者、用例之间的关系(扩展关系`<<extend>>`/包含关系`<<include>>`)、参与者/用例之间的关联关系、用例/用例与参与者/参与者之间的泛化关系；

&emsp;&emsp;**③ 使用场景：** 对系统的语境建模、对系统的需求建模；

&emsp;&emsp;**④ 包含关系：** 包含联系是一种依赖联系，是指一个基本用例的行为包括了另一个用例，如果系统用例较多，不同的用例之间存在共同行为，可以将这些共同行为提取出来，单独组成一个用例。当其他用例使用这个用例时，它们就构成了包含关系。

&emsp;&emsp;**⑤ 扩展关系：** 如果在用例的执行过程中，可能出现一些异常行为，也可能会在不同的分支行为中选择执行，这时可将异常行为与可选分支抽象为一个单独的扩展用例，这样扩展用例与主用例之间就构成了扩展关系。一个用例常常有多个扩展用例。

&emsp;&emsp;**⑥ 泛化关系：** 当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。

## 1、CMM能力成熟度模型的5个阶段
&emsp;&emsp;**（1）初始级：** 软件过程的特点时杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤、项目的成功完全依赖个人的努力和英雄式核心人物的作用；

&emsp;&emsp;**（2）可重复级：** 建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功；

&emsp;&emsp;**（3）已定义级：** 管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程；

&emsp;&emsp;**（4）已管理级：** 制定了软件过程和产品质量的详细度量标准，软件过程的产品质量都被开发组织的成员理解和控制；

&emsp;&emsp;**（5）优化级：** 加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进；

## 2、CMMI能力成熟度模型集成
&emsp;&emsp;**（1）CL0（未完成）：** 过程序未执行或未得到CL1中定义的所有目标；

&emsp;&emsp;**（2）CL1（已执行）：** 其共享目标时将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标;

&emsp;&emsp;**（3）CL2（已管理）：** 其共性目标集中于一管理的过程的制度化；

&emsp;&emsp;**（4）CL3（已定义级）：** 其共性目标集中于已定义的过程的制度化；

&emsp;&emsp;**（5）CL4（定量管理级）：** 其共性目标集中于定量管理级的过程的制度化；

&emsp;&emsp;**（6）CL5（优化级）：** 使用量化（统计学）手段改变和优化过程域；

## 3、软件过程模型
&emsp;&emsp;**（1）瀑布模型：** 

&emsp;&emsp;① 核心：以文档作为驱动、适合于软件需求很明确的软件项目模型

&emsp;&emsp;② 优点：容易理解、管理成本低

&emsp;&emsp;③ 缺点：需求必须清晰完整、需求或设计错误在后期才会发现、项目风控能力弱、项目易延期


&emsp;&emsp;**（2）增量模型：** 

&emsp;&emsp;① 核心：是瀑布模型的变体，强调每一个增量均发布一个可操作产品

&emsp;&emsp;② 优点：第一个可交付版本所需成本和时间低、开发由增量表示的小系统所承担的风险不大；减少客户需求变更；运行增量投资；

&emsp;&emsp;③ 缺点：早期需求要清晰稳定，否则会影响开发进度

&emsp;&emsp;**（3）演化模型：**

&emsp;&emsp;① 概述：演化模型是迭代的过程模型，专门应对不断演变的软件产品，特别适合用于对软件需求缺乏准确认识的情况；分为原型模型和螺旋模型

&emsp;&emsp;② 原型模型：  

&emsp;&emsp;&emsp;1）适用场景：系统规模不大，也不太复杂，用户需求不清，需求经常变化的情况；  
&emsp;&emsp;&emsp;2）基本步骤：=>交流=>快速计划=>构建原型=>部署交付和反馈=>  

&emsp;&emsp;③ 螺旋模型：

&emsp;&emsp;&emsp;1）适用场景：将瀑布模型和演化模型结合，加入风险分析，应用于复杂的大型的，具有高风险的软件系统  
&emsp;&emsp;&emsp;2）主要工作步骤：制定计划、风险分析、实施工程、用户评估  
&emsp;&emsp;&emsp;3）优点：支持用户需求动态变化，有助于提高软件适应能力，降低软件开发风险  
&emsp;&emsp;&emsp;4）缺点：需要开发人员具有相当丰富经验，多次迭代会增加开发成本，延迟交付时间  

&emsp;&emsp;**（4）喷泉模型：**

&emsp;&emsp;① 核心：以用户需求为动力，以对象为驱动的模型，适合与面向对象开发方法；

&emsp;&emsp;② 概述：开发过程具有迭代性和无间隙性，即开发中多次重复开发活动，迭代中不断完善以及开发活动没有明显边界;与瀑布模型的那顺序进行不同，喷漆模型允许开发活动交叉、迭代进行

&emsp;&emsp;③ 优点：开发人员可同步进行，提高开发效率，节省开发时间

&emsp;&emsp;④ 缺点：由于各个开发阶段重叠，需要大量人员，不利于项目管理；需要雅阁管理文档，审核难度加大

&emsp;&emsp;**（5）统一过程(UP)模型**  

&emsp;&emsp;① 核心：用例和风险驱动，以架构为中心，迭代并且增量

&emsp;&emsp;② 主要阶段：起始阶段、精化阶段、构建阶段、移交阶段

## 4、敏捷方法

&emsp;&emsp;① 核心：尽可能早地、持续地对有价值的软件交付，在软件开发过程中加入灵活性

&emsp;&emsp;② 典型方法：

&emsp;&emsp;&emsp;1）极限编程(XP)

&emsp;&emsp;&emsp;是一种轻量、高效、低风险、柔性、可预测的、科学的软件开发方式

&emsp;&emsp;&emsp;组成部分：价值观、原则、实践、行为

&emsp;&emsp;&emsp;四大价值观：沟通、简单性、反馈和勇气

&emsp;&emsp;&emsp;最佳实践：计划实践（快速制定计划，随细节变化而完善）、小型发布、简单设计、测试先行（先写测试代码再编写程序）、重构、持续集成、每周工作40小时、现场客户和编码标准；

&emsp;&emsp;&emsp;2）水晶法(Crystal)

&emsp;&emsp;&emsp;每个不同的项目都需要一套不同的策略、约定和方法论，开发人员的素质对项目质量有很大的影响

&emsp;&emsp;&emsp;3）并列争求法(Scrum)

&emsp;&emsp;&emsp;使用迭代的方法，30天的迭代为一个冲刺，按需求优先级来实现产品，多个自组织或自治小组并行地递增实现产品。

&emsp;&emsp;&emsp;4）自适应软件开发(ASD)

&emsp;&emsp;&emsp;使自适应软件开发6个原则：有一个使命作为指导、特征被视为客户价值的关键点、”重做“与”做“同样关键、变化不被视为改正而是对开发实际情况的调整、交付时间确定迫使开发人员认真考虑每一个生产版本的关键需求；

&emsp;&emsp;&emsp;5）敏捷统一过程(AUP)

&emsp;&emsp;&emsp;核心：采用在大型上连续，在小型上迭代的原理构建软件系统

&emsp;&emsp;&emsp;特点：采用经典的UP阶段性活动(初始、精化、构建、转换)；一个团队迭代使用敏捷开发，将有意义的软件增量尽快交付；

&emsp;&emsp;&emsp;AUP迭代执行活动：建模、实现、测试、部署、配置及项目管理、环境管理

## 8、什么是动态绑定？
&emsp;&emsp;动态绑定是指在运行时把过程调用和响应调用所需要执行的代码加以结合；

