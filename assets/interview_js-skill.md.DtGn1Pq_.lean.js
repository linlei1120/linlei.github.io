import{_ as r,c as e,a2 as t,o}from"./chunks/framework.Cy5ZJKdt.js";const b=JSON.parse('{"title":"JavaScript面试题集","description":"","frontmatter":{},"headers":[],"relativePath":"interview/js-skill.md","filePath":"interview/js-skill.md"}'),n={name:"interview/js-skill.md"};function s(i,a,l,p,h,d){return o(),e("div",null,a[0]||(a[0]=[t('<h1 id="javascript面试题集" tabindex="-1">JavaScript面试题集 <a class="header-anchor" href="#javascript面试题集" aria-label="Permalink to &quot;JavaScript面试题集&quot;">​</a></h1><p>JavaScript是一种动态的编程语言，广泛应用于网页开发中，主要用于增强网页的交互性和动态性。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noreferrer">查看JavaScript文档地址</a>。</p><h2 id="_1、原生js如何添加、删除、移动、复制、创建和查找节点" tabindex="-1">1、原生JS如何添加、删除、移动、复制、创建和查找节点？ <a class="header-anchor" href="#_1、原生js如何添加、删除、移动、复制、创建和查找节点" aria-label="Permalink to &quot;1、原生JS如何添加、删除、移动、复制、创建和查找节点？&quot;">​</a></h2><p><strong>（1）添加创建</strong>：document.createElement()<br><strong>（2）删除</strong>：document.parentNode.removeChild()<br><strong>（3）移动</strong>：targetNode.appendChild(nodeToMove)<br><strong>（3）复制</strong>：nodeToCopy.cloneNode(true)<br><strong>（3）查找</strong>：document.getElementById()、getElementsByClassName()、querySelector()、querySelectorAll()、getElementsByTagName()</p><h2 id="_2、数组对象的操作方法有哪些" tabindex="-1">2、数组对象的操作方法有哪些？ <a class="header-anchor" href="#_2、数组对象的操作方法有哪些" aria-label="Permalink to &quot;2、数组对象的操作方法有哪些？&quot;">​</a></h2><p><strong>（1）插入和删除</strong>：<br>   push()、pop():尾部插入和删除数组中一个或多个元素，会修改数组；<br>   unshift() 、shift():首部插入和删除数组中一个或多个元素，会修改数组；</p><p><strong>（2）转换方法</strong>：<br>   slice(start, end):start可选参数表示开始截取的位置，end表示结束截取的位置，该方法不会改变原数组，会返回一个新的数组；</p><p>  splice(start, num, value):start可选参数表示开始替换的位置，num表示替换删除的元素个数，value表示替换的新元素，该方法改变原数组；</p><p>  join(string)：用于将数组元素连接成一个字符串的方法，string为需要指定的分割符，默认指定为逗号；</p><p>  toString(arr)：用于将数组转化为字符串；</p><p>  map((e)=&gt;{})：通过指定函数处理数组每个元素，返回新数组;</p><p>  filter((e)=&gt;{})：返回数组中满足条件的元素组成的新数组;</p><p><strong>（3）其他方法</strong>：<br>   reverse()反转数组、sort()数组排序、concat()连接数组、forEach()数组循环；</p><h2 id="_3、call-apply-bind的区别" tabindex="-1">3、Call\\Apply\\Bind的区别 <a class="header-anchor" href="#_3、call-apply-bind的区别" aria-label="Permalink to &quot;3、Call\\Apply\\Bind的区别&quot;">​</a></h2><p><strong>（1）相同点</strong>：都可以用于改变this的指向，传入的第一个参数都是绑定this的指向，若第一个参数是null或undefined，则会把全局对象window作为this的值；</p><p><strong>（2）不同点</strong>：<br> ① Call传入的是参数列表，但只能一次传入，而Apply传入的是数组，Bind传入的也是参数列表，但是可以多次传入； ② Call和Apply会立即调用，适用于需要立即执行函数并改变上下文的场景；而Bind返回的是一个改变this指向的函数，适用需要创建一个新的函数，可以预先设定部分参数以便后续调用；</p><h2 id="_4、什么是事件循环" tabindex="-1">4、什么是事件循环？ <a class="header-anchor" href="#_4、什么是事件循环" aria-label="Permalink to &quot;4、什么是事件循环？&quot;">​</a></h2><p>‌  首先由于JS是单线程的，所以为了避免阻塞，JS会将事件分为同步事件和异步事件，同步事件会在执行栈中立即执行并等待结果，而异步事件则会先放到宿主环境中，然后推送到执行队列，每次当执行栈中的同步事件执行完毕之后就回到执行队列中查找是否有异步事件需要执行，以此循环的查找过程就称为事件循环。 ‌  浏览器中事件循环和NodeJS中事件循环的主要区别就在于前者的异步任务分别为宏任务队列和微任务队列，而后者NodeJS中的事件循环的异步任务分成了6个任务队列。</p><h2 id="_5、什么是宏任务和微任务" tabindex="-1">5、什么是宏任务和微任务？ <a class="header-anchor" href="#_5、什么是宏任务和微任务" aria-label="Permalink to &quot;5、什么是宏任务和微任务？&quot;">​</a></h2><p>‌  首先JS是单线程的，所以为了避免阻塞，JS会将事件分为同步任务和异步任务，而异步任务则会分为宏任务和微任务，宏任务通常由浏览器或者Node发起如script/请求事件/定时器等，而微任务则由JS引擎自身发起如Promise(注意Promise本身是同步的，但是.then()和.catch()会让其异步执行)，Async/Await等；事件会按照首先在执行栈中同步任务、将微任务放入任务队列、将宏任务放入宏任务队列，待同步任务执行完毕后回去查找微任务队列中的事件执行，然后再去查找宏任务中的队列去执行。</p><h2 id="_6、什么是事件响应链" tabindex="-1">6、什么是事件响应链？ <a class="header-anchor" href="#_6、什么是事件响应链" aria-label="Permalink to &quot;6、什么是事件响应链？&quot;">​</a></h2><p>  事件响应链是指当一个事件发生DOM元素上时，该事件会从特定的事件目标开始逐级传播到其他事件监听者，这个事件传播的过程分为三个阶段：捕获阶段(最外层开始逐级向内传播)、目标阶段(事件到达事件目标)、冒泡阶段(目标事件开始开始逐级向内传播)；<br>   在实际开发中，可以利用事件捕获阶段来处理事件拦截或者事件的预处理，而冒泡阶段则用于执行主要的事件处理逻辑。可以通过<code>addEventListener</code>函数的第三个参数来决定监听器是在捕获阶段还是冒泡阶段触发。</p><h2 id="_7、什么是事件委托" tabindex="-1">7、什么是事件委托 <a class="header-anchor" href="#_7、什么是事件委托" aria-label="Permalink to &quot;7、什么是事件委托&quot;">​</a></h2><p>  事件委托，称事件代理，是 js 中很常用的绑定事件的技巧，事件委托就是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件委托的原理是 DOM 元素的事件冒泡；</p><h2 id="_8、js的垃圾回收机制-gc" tabindex="-1">8、JS的垃圾回收机制(GC) <a class="header-anchor" href="#_8、js的垃圾回收机制-gc" aria-label="Permalink to &quot;8、JS的垃圾回收机制(GC)&quot;">​</a></h2><p>  垃圾回收是一种自动内存管理机制，用于检测和清除不再使用的对象以释放内存空间，当一个对象不再被引用，垃圾回收器会将其进行标记，然后在适当的时候清除这些垃圾，并将内存回收给系统以供其他对象使用，其目的是减少内存泄露和提高程序的性能，而JS引擎的垃圾回收是自动执行的，无需像C和C++语言需要手动管理； 垃圾回收算法：<br>   <strong>①引用计数</strong>：通过跟踪每个对象被引用的次数来确定对象是否为垃圾，每个对象都有一个引用计数器，当对象被创建时计数器为1，引用则加1，不被引用时减1，减至0时，则可以被垃圾收集器回收；<br>   <strong>注意</strong>：引用计数器对于循环引用情况时，引用计数都不会为0，导致无法处理容易造成内存泄漏；<br>   <strong>①标记-清除</strong>：通过标记不再使用的对象，然后清除这些对象的内存空间以便后续内存分配使用；标记阶段：堆内存中所有对象遍历，递归地遍历对象的引用关系，并给每个对象打上标记表示对象时可达的不是垃圾；清楚阶段：同样遍历整个内存，对于未标记的对象，判定为垃圾并立即回收释放内存空间；<br>   <strong>注意</strong>：标记-清除算法会存在垃圾回收过程中暂停进行垃圾回收操作现象，影响用户体验；还会在回收过程中阐述大量不连续的，碎片化的内存空间，导致内存利用率低；<br>   <strong>③ 标记-整理</strong>：主要分为标记阶段、整理阶段、清除阶段；相当于标记-清除的增强操作，在清除阶段会先执行整理操作，移动对象位置，对内存空间进行压缩；解决了内存碎片化的问题；<br>   <strong>注意</strong>：标记-整理算法同样会暂停程序的执行，进行垃圾回收操作；</p><h2 id="_9、map和foreach的区别" tabindex="-1">9、map和forEach的区别 <a class="header-anchor" href="#_9、map和foreach的区别" aria-label="Permalink to &quot;9、map和forEach的区别&quot;">​</a></h2><p>  <strong>相同点:</strong>   (1)都是循环遍历数组中的每一项。</p><p>  (2)每次执行匿名函数都支持三个参数，参数分别为item(当前每一项)，index(索引值)，arr(原数组)。</p><p>  (3)匿名函数中的this都是指向window。</p><p>  (4)只能遍历数组。</p><p>  <strong>不同点:</strong></p><p>  (1)map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</p><p>  (2)forEach()允许callback更改原始数组的元素。map()返回新的数组。</p><h2 id="_10、js为什么是单线程" tabindex="-1">10、JS为什么是单线程 <a class="header-anchor" href="#_10、js为什么是单线程" aria-label="Permalink to &quot;10、JS为什么是单线程&quot;">​</a></h2><p>  JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等待。因为JS脚本语言主要是作为交互功能使用，比如操作DOM结点等，所以使用单线程，若使用多线程一边增加DOM节点，一边删除DOM节点，这样则会增加复杂性；</p><h2 id="_11、对于webworker的了解" tabindex="-1">11、对于WebWorker的了解 <a class="header-anchor" href="#_11、对于webworker的了解" aria-label="Permalink to &quot;11、对于WebWorker的了解&quot;">​</a></h2><p>  Web Worker是一种为Web后台新增线程的一种简单方法，也就行单独运行JS的一种方法，新增线程的脚本独立于其他脚本，不会影响页面的性能，包括使用Ajax或Fetch发送请求等；WebWorker分为专用worker和共享worker；   创建方式：<code>w = new Worker(&quot;demo_workers.js&quot;);</code></p><h2 id="_12、对于ts的了解以及与js的区别" tabindex="-1">12、对于TS的了解以及与JS的区别 <a class="header-anchor" href="#_12、对于ts的了解以及与js的区别" aria-label="Permalink to &quot;12、对于TS的了解以及与JS的区别&quot;">​</a></h2><p>  TS是JS的超集，它在JS的基础上添加了强类型、接口、类、泛型等等特性，并提供了静态类型检查等功具，可以是开发者在编写代码时更加安全、可靠；与JS相比，TS具有更强的类型系统，更严格的类型检查，更好的代码可读性以及维护性等优点。TS更加适合中大型的应用开发，更注重可持续性和可维护性等。</p><h2 id="_13、ts的重载函数是什么" tabindex="-1">13、TS的重载函数是什么 <a class="header-anchor" href="#_13、ts的重载函数是什么" aria-label="Permalink to &quot;13、TS的重载函数是什么&quot;">​</a></h2><p>  TypeScript中的函数重载是指定义多个具有相同名称的函数，但具有不同的参数类型或参数数量。通过函数重载，可以为不同的参数类型或参数数量提供不同的函数实现；</p>',42)]))}const g=r(n,[["render",s]]);export{b as __pageData,g as default};
